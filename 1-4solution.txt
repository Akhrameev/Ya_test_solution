////////Вопрос 1
////////Напишите представление числа -1, имеющего тип int16_t, в двоичной системе счисления.

1111111111111111 (16 единичек).
Если прибавить 1 - то единичка слева "не влезет" - и мы получим 16 нулей, то есть бинарное представление нуля.

////////Вопрос 2
////////Объясните, что делает следующее выражение:
////////(n & (n - 1)) != 0

выполняется следующее:
1, 2. 	вычисляется выражение n
3.		вычисляется выражение n-1
	типы результата вычисления выражений (n) и (n-1) совпадают - выравнивание не должно выполняться
4.		выполняется побитовое "и" над результатами вычислений выражений
5.		сравнивается результат выполнения побитового "и" с 0.

Таким образом, суммарное выражение вернет ложь когда результат вычисления выражений (n) и (n-1) в каждом разряде будет по нулю.
Итоговое выражение верно для всех чисел, кроме степеней двойки и 0.
То есть минимальное положительное число, возвращаещее в этом ЧИСЛОВОМ выражении истину - тройка 
(0, 1, 2, 4 и т.д. вернул ложь, так как побитовое "и" в их случае даст нули на всех позициях)

Если переопределить n через #define, можно добиться того, что на любой паре это выражение вернет нужный нам ответ 
(как ложь, так и истину).
Для примера рассмотрим

#define n (nfunc())
int nfunc() {
    static unsigned int i = 0;
    if (i++) {
        return 2;
    }
    return 3;
}
Выражение (n & (n - 1)) != 0 при первом вычислении вернет истину, а потом часто будет возвращать ложь. 

////////Вопрос 3
////////Опишите алгоритмическую сложность следующих операций для NSMutableArray в среднем и в худшем случаях:

Ответ в основном взял с opensource.apple.com

NSMutableArray
а) вставка нового элемента в начало структуры;
	- usually an O(1)
	- usually worst O(N) - см [2]
	There are no favored positions within the array for performance См. пункт д) 
б) вставка нового элемента в конец структуры;
	- usually an O(1)
	- usually worst O(N) - см [2]
	There are no favored positions within the array for performance Cм. пункт д)
в) поиск существующего элемента по значению;
	- worst O(N*lg N)
	- usually less
г) поиск существующего элемента по индексу;
	- worst O(lg N)
	- usually O(1)
д) удаление существующего элемента.
	(и вставка тоже)
	- worst O(N*lg N)
	- usually linear

////////Вопрос 4
////////Опишите алгоритмическую сложность следующих операций для NSMutableDictionary в среднем и в худшем случаях:
	
NSMutableDictionary
а) вставка нового элемента в структуру;
	- usually O(1)
	- worst O(N*N)
б) поиск существующего элемента по ключу;
	- usually O(1)
	- worst O(N)
в) удаление существующего элемента по ключу.
	- usually O(1)
	- worst O(N*N)

[0] http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h	
[1] http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h
[2] http://www.objc.io/issue-7/collections.html
