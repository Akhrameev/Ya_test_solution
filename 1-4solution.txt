////////Вопрос 1
////////Напишите представление числа -1, имеющего тип int16_t, в двоичной системе счисления.

1111111111111111 (16 единичек).
Если прибавить 1 - то единичка слева "не влезет" - и мы получим 16 нулей, то есть бинарное представление нуля.

////////Вопрос 2
////////Объясните, что делает следующее выражение:
////////(n & (n - 1)) != 0

выполняется следующее:
1, 2. 	вычисляется выражение n
3.		вычисляется выражение n-1
	типы результата вычисления выражений (n) и (n-1) совпадают - выравнивание не должно выполняться
4.		выполняется побитовое "и" над результатами вычислений выражений
5.		сравнивается результат выполнения побитового "и" с 0.

Таким образом, суммарное выражение вернет ложь когда результат вычисления выражений (n) и (n-1) в каждом разряде будет по нулю.
Итоговое выражение верно для всех чисел, кроме степеней двойки и 0.
То есть минимальное положительное число, возвращаещее в этом ЧИСЛОВОМ выражении истину - тройка 
(0, 1, 2, 4 и т.д. вернул ложь, так как побитовое "и" в их случае даст нули на всех позициях)

Если переопределить n через #define, можно добиться того, что на любой паре это выражение вернет нужный нам ответ 
(как ложь, так и истину).
Для примера рассмотрим

#define n (nfunc())
int nfunc() {
    static unsigned int i = 0;
    if (i++) {
        return 2;
    }
    return 3;
}
Выражение (n & (n - 1)) != 0 при первом вычислении вернет истину, а потом часто будет возвращать ложь. 

////////Вопрос 3
////////Опишите алгоритмическую сложность следующих операций для NSMutableArray в среднем и в худшем случаях:

Ответ в основном взял с opensource.apple.com

NSMutableArray
а) вставка нового элемента в начало структуры;
	- usually an O(1)
	- usually worst O(N) - см [2]
	There are no favored positions within the array for performance См. пункт д) 
б) вставка нового элемента в конец структуры;
	- usually an O(1)
	- usually worst O(N) - см [2]
	There are no favored positions within the array for performance Cм. пункт д)
в) поиск существующего элемента по значению;
	- worst O(N*lg N)
	- usually less
г) поиск существующего элемента по индексу;
	- worst O(lg N)
	- usually O(1)
д) удаление существующего элемента.
	(и вставка тоже)
	- worst O(N*lg N)
	- usually linear

////////Какую структуру данных вы бы использовали для реализации NSMutableArray с учётом ваших требований к алгоритмической сложности?
Ничего примечательного я в этих оценках не нашёл, они достигаются классическими решениями, которые рассказывают в ВУЗе [4].
На небольших массивах эти оценки достигаются очевидными действиями вроде выделять память порциями (с запасом) 
и из-за этого реже вызывать realloc/mmap. 
Из документации известно, что CFArray при удалении элементов перераспределяет счетчики на элементы массива, не затрагивая непосредствонно хранимые данные.
Это решение вызывает интерес, но на оценку сложности (это грубый способ сравнить алгоритмы: несколько методов с одинаковой оценкой сложности могут 
отличаться в производительности на большую константу) влияния не оказывает.
Классическая реализация массива вполне удовлетворяет вышеописанным оценкам. 
Детально оптимизации вроде mmap'ов от разработчиков обычно скрыты за интерфейсом. 
Перед тем как взяться за свою реализацию, я бы изучил детально много аналогов.

////////Вопрос 4
////////Опишите алгоритмическую сложность следующих операций для NSMutableDictionary в среднем и в худшем случаях:
	
NSMutableDictionary
а) вставка нового элемента в структуру;
	- usually O(1)
	- worst O(N*N)
б) поиск существующего элемента по ключу;
	- usually O(1)
	- worst O(N)
в) удаление существующего элемента по ключу.
	- usually O(1)
	- worst O(N*N)

////////Какую структуру данных вы бы использовали для реализации NSMutableDictionary с учётом ваших требований к алгоритмической сложности?
В словарях также оценки не удивляют: классическая хеш-таблица дает даже лучшие оценки [3]. 
Я обычно представляю себе словарь именно хеш-таблицей.

[0] http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h	
[1] http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h
[2] http://www.objc.io/issue-7/collections.html
[3] http://en.wikipedia.org/wiki/Hash_table
[4] http://en.wikipedia.org/wiki/Array_data_structure#One-dimensional_arrays
