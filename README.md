# Ya_test_solution
Через GMS Services (Алексея Исаева) получил тестовое задание в Яндекс на мобильного iOS/Android-разработчика. Я заинтересовался iOS-частью. Собственно, мое решение.

Мне досталось 5 заданий. С первого по четвёртое они решены в файле [1-4solution.txt](1-4solution.txt)

## Задача 5
> Напишите реализацию для функции, которая принимает на вход последовательность ASCII-символов и выдаёт самый часто повторяющийся символ:
```
char mostFrequentCharacter(char* str, int size);
```
Функция должна быть оптимизирована для выполнения на устройстве с двухядерным ARM-процессором и бесконечным количеством памяти.


Пятое задание привносит основные файлы в репозиторий, хотя на деле нужен только [main.c](MaxOccursInArray/main.c)
Оно решено мной на чистом Си, в котором не гладко с обработкой ошибок. Обычно можно использовать эскалацию ошибок (много-много системных функций в случае неудачи возвращают код ошибки или пустой указатель - и тогда нужно смотреть ```errno```). В данной задаче возвращаемое значение и аргументы функции фиксированы. Механизм исключений в Си отсутствует. В задаче явно не указано, что данные на входе коректны. errno использовать в этой задаче мне показалось не лучшим выходом, так как обычно эту переменную используют системные функции.
В итоге, я реализовал более гибкий способ (чем через ```errno```) - с сигналами. Обработчик сигнала пользователь функции может установить сам - пример я привел.

Проверить на очевидные ошибки при передаче некорректного значения в качестве параметра ```size``` (```int``` может быть как положительным, так и неположительным - что некорректно) мне удалось. Проверить, что я не читаю мусор из памяти при передаче некорректного указателя, вроде, невозможно. По-этому никаких проверок на входной указатель я не добавлял (даже не сравниваю его с нулем, хотя это, в целом, имеет смысл).

##Итог
Задача решена (тесты выполняются). На массивах большой длины (по умолчанию больше ```16384```) задача распараллеливается - и выполняется, действительно, примерно в два раза (двухъядерный арм) быстрее, чем при однопоточном решении.
