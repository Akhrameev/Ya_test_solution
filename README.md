# Ya_test_solution
Через GMS Services (Алексея Исаева) получил тестовое задание в Яндекс на мобильного iOS/Android-разработчика. Я заинтересовался iOS-частью. Собственно, мое решение.

Мне досталось 5 заданий. С первого по четвёртое они решены в файле 1-4solution.txt

# Задача 5
> Напишите реализацию для функции, которая принимает на вход последовательность ASCII-символов и выдаёт самый часто повторяющийся символ:
```
char mostFrequentCharacter(char* str, int size);
```
Функция должна быть оптимизирована для выполнения на устройстве с двухядерным ARM-процессором и бесконечным количеством памяти.


Пятое задание привносит основные файлы в репозиторий, хотя на деле нужен только main.c
Оно решено мной на чистом Си, в котором не гладко с обработкой ошибок. Обычно можно использовать эскалацию ошибок (много-много системных функций возвращают код ошибки в случае неудачи или пустой указатель - и тогда нужно смотреть errno). В данной задаче возвращаемое значение и аргументы функции фиксированы. Механизм исключений в Си отсутствует. В задаче явно не указано, что данные на входе коректны. errno использовать в этой задаче мне показалось не лучшим выходом, так как обычно эту переменную используют системные функции.
В итоге, я реализовал более гибкий способ (чем через errno) - с сигналами. Обработчик сигнала пользователь функции может установить сам - пример я привел.

Проверить на очевидные ошибки при передаче некорректного значения в качестве параметра size (int может быть как положительным, так и неположительным - что некорректно) мне удалось. Проверить, что я не читаю мусор из памяти при передаче некорректного указателя, вроде, невозможно. По-этому никаких проверок на входной указатель я не добавлял (даже не сравниваю его с нулем, хотя это, в целом, имеет смысл).

В качестве итога скажу, что задача решена (тесты выполняюстя). На массивах большой длины (по умолчанию больше 16384) задача распарралеливается - и выполняется, дествительно, примерно в два раза быстрее, чем при однопоточном решении.
